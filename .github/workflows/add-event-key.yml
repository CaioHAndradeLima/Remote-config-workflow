name: Add a new event key

on:
  workflow_dispatch:
    inputs:
      new_event_name:
        description: "Event key name in snake case"
        required: true
        type: string

      target_tool:
        description: "Marketing tool"
        required: true
        default: "firebase"
        type: choice
        options:
          - braze
          - firebase

jobs:
  add_event:
    runs-on: ubuntu-latest

    env:
      FIREBASE_PROJECT_ID: ${{ secrets.FIREBASE_PROJECT_ID }}
      FIREBASE_CLIENT_EMAIL: ${{ secrets.FIREBASE_CLIENT_EMAIL }}
      FIREBASE_PRIVATE_KEY: ${{ secrets.FIREBASE_PRIVATE_KEY }}

    steps:
      - name: üì¶ Checkout repository
        uses: actions/checkout@v4

      # ‚úÖ Step 1: Validate if the event is snake_case
      - name: üêç Step 1 - Validate snake_case (single or comma-separated)
        run: |
          chmod +x .github/action/check-snake-case.sh
          source .github/action/check-snake-case.sh
          
          raw_input="${{ github.event.inputs.new_event_name }}"
          echo "üîç Raw input: $raw_input"
          
          # Split by comma and trim whitespace
          IFS=',' read -ra EVENTS <<< "$raw_input"
          
          all_valid=true
          
          for event in "${EVENTS[@]}"; do
            event_trimmed="$(echo "$event" | xargs)" # trim whitespace
          
            echo "üîç Validating event name: '$event_trimmed'"
          
            if is_snake_case "$event_trimmed"; then
              echo "‚úÖ '$event_trimmed' is valid"
            else
              echo "‚ùå '$event_trimmed' is not valid (must be snake_case)"
              all_valid=false
            fi
          done
          
          if [ "$all_valid" = false ]; then
            echo "‚ùå One or more event names are invalid. Aborting."
            exit 1
          fi
          
          echo "‚úÖ All event names are valid."

      # üîê Step 2: Generate Firebase Token
      - name: üîê Step 2 - Generate Firebase Token
        id: get_token
        run: |
          echo "üì• Requesting Firebase token..."

          PRIVATE_KEY_CLEAN=$(echo "${FIREBASE_PRIVATE_KEY}" | sed 's/\\n/\n/g')

          RESPONSE=$(.github/action/generate-firebase-token.sh "${FIREBASE_CLIENT_EMAIL}" "$PRIVATE_KEY_CLEAN")

          ACCESS_TOKEN=$(echo "$RESPONSE" | jq -r '.access_token // empty')

          if [[ -z "$ACCESS_TOKEN" ]]; then
            echo "‚ùå Failed to retrieve access_token from Firebase. Stopping workflow."
            echo "::set-output name=error::true"
            echo "::set-output name=message::Failed to retrieve access_token from Firebase."
            exit 1
          fi

          echo "‚úÖ Firebase token acquired."
          echo "token=$ACCESS_TOKEN" >> $GITHUB_OUTPUT
      # üì• Step 3: Download Remote Config Template
      - name: üì• Step 3 - Get Remote Config Template
        id: get_remote_config
        run: |
          echo "üì• Requesting Remote Config template..."
          chmod +x .github/action/firebase-get-request.sh
          
          PROJECT_ID="${FIREBASE_PROJECT_ID}"
          ACCESS_TOKEN="${{ steps.get_token.outputs.token }}"
          OUT_FILE=".remote_config.json"
          
          .github/action/firebase-get-request.sh "$PROJECT_ID" "$ACCESS_TOKEN" "$OUT_FILE"
          
          echo "‚úÖ Remote config saved to $OUT_FILE"

      # ‚ûï Step 4: Add event to allowed_event_keys
      - name: ‚ûï Step 4 - Add event(s) to list
        id: add_event
        run: |
          CONFIG_FILE=".remote_config.json"
          PARAM_KEY="${{ github.event.inputs.target_tool }}"
          RAW_EVENTS="${{ github.event.inputs.new_event_name }}"
          UPDATED_FILE="updated_remote_config.json"
          
          chmod +x .github/action/add-event-key.sh
          
          echo "üîç Preparing to add event(s) to $PARAM_KEY: $RAW_EVENTS"
          
          # Split by comma and trim each item
          IFS=',' read -ra EVENTS <<< "$RAW_EVENTS"
          
          TEMP_FILE="$CONFIG_FILE"
          
          for event in "${EVENTS[@]}"; do
            TRIMMED_EVENT="$(echo "$event" | xargs)" # trim whitespace
          
            echo "üîß Adding event: '$TRIMMED_EVENT'"
            .github/action/add-event-key.sh "$TEMP_FILE" "$PARAM_KEY" "$TRIMMED_EVENT"
          
            # Update the input file for the next loop
            TEMP_FILE="updated_$TEMP_FILE"
          done
          
          # Final output rename
          mv "$TEMP_FILE" "$UPDATED_FILE"
          
          echo "‚úÖ All events processed. Output written to $UPDATED_FILE"

      # üõ°Ô∏è Step 5 - Check JSON integrity before pushing update
      - name: üõ°Ô∏è Step 5 - Check JSON integrity before pushing update
        id: check_integrity
        run: |
          ORIGINAL_FILE=".remote_config.json"
          UPDATED_FILE="updated_remote_config.json"
          PARAM_KEY="${{inputs.target_tool}}"

          chmod +x .github/action/check-json-integrity.sh

          echo "üîç Validating JSON integrity..."
          .github/action/check-json-integrity.sh "$PARAM_KEY" "$ORIGINAL_FILE" "$UPDATED_FILE"

          echo "‚úÖ JSON integrity confirmed."

      # üöÄ Step 6 - Push updated Remote Config to Firebase
      - name: Step 6 - Push updated config to Firebase
        if: ${{ steps.check_integrity.outcome == 'success' }}
        run: |
          PROJECT_ID="${FIREBASE_PROJECT_ID}"
          CONFIG_FILE="updated_remote_config.json"
          
          chmod +x .github/action/put-remote-config.sh
          echo "üöÄ Sending updated config to Firebase..."
          .github/action/put-remote-config.sh "${{ steps.get_token.outputs.token }}" "$PROJECT_ID" "$CONFIG_FILE"
